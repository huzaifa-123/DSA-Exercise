# -*- coding: utf-8 -*-
"""200901010-DSA-ASSIGNMENT_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PVtlftYCC6btZ7FOvMhjiAeOs8Nx8FPk

* **DATA STRUCTURE AND ALGORITHM**   
* **ASSIGNMENT-1**
* **NAME: HUZAIFA AHMED**
* **REG# 200901010**

**Question-1**


**Answer:** The value returned during the given stack poperation is 9 .

**Question-2**


**Answer:** The current size of stack is 18.
"""

#Question-3
class Empty(Exception):
    pass

class Stack():
    def __init__(self):
        self._data = []
         
    def __len__(self):
        return len(self._data)
    
    def is_empty(self):
        return len(self._data) == 0
    
    def push(self, value):
        self._data.append(value)
    
    def top(self):
        return self._data[-1]
    
    def pop(self):
        if self.is_empty():
            raise Empty('List is empty')
        return self._data.pop()
    
    def full_pop(self):
        ans = []
        while not self.is_empty():
            ans.append(self.pop())
        return ans
    
def transfer(S, T):
    while not S.is_empty():
        T.push(S.pop())



S,T = Stack(), Stack()

try: S.pop()
except Exception as e: print (e)

for i in range(20):
    S.push(i)
    
print('Top of S is: ', S.top())
transfer(S, T)  
print('Top of T is: ', T.top())
S.full_pop(), T.full_pop()

#Question-4
def remove_all(stack):
	def helper(stack,stack_size):
		if len(stack) == 0:
			return stack
		stack.pop()
		if stack is None:
			stack = ArrayStack()
			return stack
		return helper(stack, len(stack))
	stack = helper(stack,len(stack))
	return stack

#Question-5
def reverse_elem(array):
	stack = ArrayStack()
	for i in range(len(array)):
		stack.push(array[i])
	for i in range(len(array)):
		array[i] = stack.pop()
	return array

#Question-7
#Procedure
class ArrayQueue:
    
    DEFAULT_CAPACITY = 10
    
    def __init__(self):
        self._data = [None] * ArrayQueue.DEFAULT_CAPACITY
        self._size = 0
        self._front = 0
        
    def __len__(self):
        return self._size
    
    def is_empty(self):
        return self._size == 0
    
    def first(self):
        if self.is_empty():
            raise Empty("Queue is empty")
        return self._data[self._front]
    
    def dequeue(self):
        
        if self.is_empty():
            raise Empty("Queue is empty")
        answer = self._data[self._front]
        self._data[self._front] = None
        self._front = (self._front +1) % len(self._data)
        self._size -= 1
        
        if 0 < self._size < len(self._data) // 4:
            self._resize(len(self._data) // 2)
        return answer
    
    def enqueue(self, e):
        if self._size == len(self._data):
            self._resize(2 * len(self._data))
        avail = (self._front + self._size) % len(self._data)
        self._data[avail] = e
        self._size += 1
    
    def _resize(self, cap):
        
        old = self._data
        self._data = [None] * cap
        walk = self._front
        for k in range(self._size):
            self._data[k] = old[walk]
            walk = (1 + walk) % len(old)
        self._front = 0
x = ArrayQueue()
x.enqueue(5)
x.enqueue(3)
x.dequeue()
x.enqueue(2)
x.enqueue(8)
x.dequeue()
x.dequeue()
x.enqueue(9)
x.enqueue(1)
x.dequeue()
x.enqueue(7)
x.enqueue(6)
x.dequeue()
x.dequeue()
x.enqueue(4)
x.dequeue()
x.dequeue()
#The answer is 6

"""**Question-8**

**Answer:** 32−(15−5)=22
So currently the size of Q is 22.

**Question-9**

**Answer:** It was initially an empty queue, we assume the front value was initially 0.
self._front only increments when a dequeue takes place so the final value would be 10 ahead of its initial value, 
or self._front == 10 is self._front was initially 0 as assumed. More generally, it's (10+initial) % 30

**Question-10**

**Answer:** This method will copy the data in exactly, but now there will be a huge gap between the middle of the data
filled with None and the next value (which is situated at ._data[0])

ex. a queue with 1,2,3,4,5,6,7 with front = 3:
      F
5,6,7,1,2,3,4

would become:
      F
5,6,7,1,2,3,4,N,N,N,N,N,N,N

the next insertion would be at front + self._size, which would be:
      F
5,6,7,1,2,3,4,N,N,N,8,N,N,N and so on, which results in the fragmentation of the data.  Successive dequeues would 
result in 1,2,3,4,N,N,N,....., N,N instead of the desired 1,2,3,4,5,6,7, is_empty==True


In contract, the walk assures that the data will stay both in order and in direct sequence, producing:

F
1,2,3,4,5,6,7,N,N,N,N,N,N,N
"""

#Question-11
import collections

class Queue():
    def __init__(self):
        self._data = collections.deque()
        self._size = 0
        
        
    def __len__(self):
        return self._size
    
    def first(self):
        return self._data[0]
        
    def enqueue(self, value):
        self._size += 1
        self._data.append(value)  #Note we append here to add an element to the end of the queue
        
    def is_empty(self):
        return self._size == 0
    
    def dequeue(self):
        if self.is_empty():
            raise ValueError('Queue is empty')
        else:
            ans = self._data.popleft()
            self._size -= 1
            return ans
        
        
dq = Queue()

for i in range(10):
    dq.enqueue(i)

    
print('First', dq.first(), 'Length', len(dq))
while not dq.is_empty():
    print( dq.dequeue(),  end = ', ')

"""**Question-12**

**Answer:** Return   Values in the Stack
-        [4]
-        [4, 8]
-        [4, 8, 9]
-        [5, 4, 8, 9]
9        [5, 4, 8, 9] 

5        [4, 8, 9]
9        [4,8]
-        [4,8,7]
4        [4,8,7]
7        [4,8,7]
-        [4,8,7,6]
4        [8,7,6]
8        [7,6]
"""

#Question-13
from queue import Queue
Q = Queue
D = collections.deque()
for i in range(1, 9, 1):
    D.append(i)
    
    
def rearrange_using_queue(D, Q):    
    for i in range(5):             
        Q.enqueue(D.popleft())     
        
    for i in range(3):
        D.append(Q.dequeue())    
        
    
    for i in range(2):
        D.appendleft(Q.dequeue())  
        
    for i in range(3):
        Q.enqueue(D.pop())        

    for i in range(3):
        D.appendleft(Q.dequeue())  
  
rearrange_using_queue(D, Q)

print('Values of Q:')
while not Q.is_empty():
    print(Q.dequeue())
    
    
print('Values of D')
while len(D) != 0:
    print(D.popleft())

#Question-14
import collections
class Stack:
     def __init__(self):
         self.items = []

     # I have changed method name isEmpty to is_empty
     # because in your code you have used is_empty
     def is_empty(self):
         return self.items == []

     def push(self, item):
         self.items.append(item)

     def pop(self):
         return self.items.pop()

     def peek(self):
         return self.items[len(self.items)-1]

     def size(self):
         return len(self.items)

S = Stack()
D = collections.deque()

for i in range(1,9,1):
    D.append(i)
    

    
def rearrange_using_stack(D, S):
    for _ in range(4):
        S.push(D.popleft())    # [5,6,7,8], [1,2,3,4]
        
    D.append(S.pop())          # [5,6,7,8,4], [1,2,3]
    
    S.push(D.popleft())        # [6,7,8,4], [1,2,3,5]
    
    S.push(D.pop())            # [6,7,8], [1,2,3,5,4]
    
    for _ in range(5):
        D.appendleft(S.pop())  #[1,2,3,5,4,6,7,8], []
    
    
    
    
    
rearrange_using_stack(D, S) 
    
    
print('Values of S')
while not S.is_empty():
    print(S.pop())
    
print('Values of D:')
while len(D) != 0:
    print(D.popleft())

